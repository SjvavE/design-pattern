# design-pattern
在这个仓库，主要会把一些常用的设计模式给列出，通过给出的一些例子，让学习者更加快速的学习到到其中的思维方式。
当然，以下是这些设计模式的按顺序的简要介绍：

1. **单例模式 (Singleton Pattern)**：确保一个类只有一个实例，并提供全局访问点。

2. **工厂模式 (Factory Pattern)**：定义一个用于创建对象的接口，让子类决定实例化哪个类。

3. **抽象工厂模式 (Abstract Factory Pattern)**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。

4. **建造者模式 (Builder Pattern)**：将一个复杂对象的构建过程分解成多个简单的步骤，使得同样的构建过程可以创建不同的表示。

5. **原型模式 (Prototype Pattern)**：通过克隆现有对象来创建新对象，而不是通过构造函数。

6. **适配器模式 (Adapter Pattern)**：允许将一个接口转换成客户端所期望的另一个接口，通常用于兼容不同接口的类。

7. **装饰器模式 (Decorator Pattern)**：动态地将责任附加到对象上，扩展其功能，而不改变其接口。

8. **观察者模式 (Observer Pattern)**：定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会得到通知并自动更新。

9. **策略模式 (Strategy Pattern)**：定义一系列算法，将每个算法封装起来，并使它们可以相互替换，使得算法可以独立于使用它的客户端而变化。

10. **命令模式 (Command Pattern)**：将一个请求封装成一个对象，从而可以参数化客户端对象，排队请求或记录请求日志，并支持可撤销的操作。

11. **迭代器模式 (Iterator Pattern)**：提供一种顺序访问聚合对象元素的方法，而不需要暴露该对象的内部表示。

12. **状态模式 (State Pattern)**：允许对象在其内部状态改变时改变其行为，看起来像是修改了其类。

13. **访问者模式 (Visitor Pattern)**：在不改变元素类的前提下，定义作用于元素对象的新操作。

14. **备忘录模式 (Memento Pattern)**：在不破坏封装性的前提下，捕获并外部化一个对象的内部状态，以便后续恢复到此状态。

15. **模板方法模式 (Template Method Pattern)**：定义一个算法的骨架，允许子类在不改变算法结构的情况下重新定义算法的某些步骤。

16. **责任链模式 (Chain of Responsibility Pattern)**：将请求沿着处理者链进行传递，直到有一个处理者能够处理它。

17. **中介者模式 (Mediator Pattern)**：定义一个中介对象来封装一系列对象之间的交互，减少对象之间的直接依赖关系。

18. **解释器模式 (Interpreter Pattern)**：给定一个语言，定义它的文法的一种表示，并定义一个解释器，用来解释语言中的句子。

19. **组合模式 (Composite Pattern)**：将对象组合成树状结构以表示"部分-整体"的层次结构，使得客户端对单个对象和组合对象的使用具有一致性。

20. **享元模式 (Flyweight Pattern)**：共享大量细粒度的对象，以减少内存和对象创建的开销。

21. **桥接模式 (Bridge Pattern)**：将抽象部分与它的实现部分分离，使它们可以独立变化。

22. **外观模式 (Facade Pattern)**：提供了一个高层次的接口，使得子系统更容易使用。

23. **代理模式 (Proxy Pattern)**：为其他对象提供一种代理以控制对这个对象的访问。
